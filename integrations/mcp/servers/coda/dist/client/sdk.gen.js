"use strict";
// This file is auto-generated by @hey-api/openapi-ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.listPackAnalytics = exports.listDocAnalyticsSummary = exports.listPageAnalytics = exports.listDocAnalytics = exports.triggerWebhookAutomation = exports.getMutationStatus = exports.resolveBrowserLink = exports.whoami = exports.getCustomDocDomainProvider = exports.updateCustomDocDomain = exports.deleteCustomDocDomain = exports.addCustomDocDomain = exports.listCustomDocDomains = exports.getControl = exports.listControls = exports.getFormula = exports.listFormulas = exports.getColumn = exports.pushButton = exports.updateRow = exports.getRow = exports.deleteRow = exports.upsertRows = exports.listRows = exports.deleteRows = exports.listColumns = exports.getTable = exports.listTables = exports.getPageContentExportStatus = exports.beginPageContentExport = exports.updatePage = exports.getPage = exports.deletePage = exports.createPage = exports.listPages = exports.publishDoc = exports.unpublishDoc = exports.updateAclSettings = exports.getAclSettings = exports.searchPrincipals = exports.deletePermission = exports.addPermission = exports.getPermissions = exports.getSharingMetadata = exports.updateDoc = exports.getDoc = exports.deleteDoc = exports.createDoc = exports.listDocs = exports.listCategories = void 0;
exports.updatePackFeaturedDocs = exports.listPackFeaturedDocs = exports.getPackLogDetails = exports.listIngestionExecutionAttempts = exports.listIngestionExecutions = exports.listGroupedIngestionLogs = exports.listGroupedPackLogs = exports.listIngestionLogs = exports.listPackLogs = exports.getPackListing = exports.listPackListings = exports.getPackSourceCode = exports.packSourceCodeUploadComplete = exports.packAssetUploadComplete = exports.uploadPackSourceCode = exports.uploadPackAsset = exports.deletePackCategory = exports.addPackCategory = exports.listPackCategories = exports.deletePackMaker = exports.addPackMaker = exports.listPackMakers = exports.deletePackPermission = exports.addPackPermission = exports.getPackPermissions = exports.setPackSystemConnection = exports.patchPackSystemConnection = exports.getPackSystemConnection = exports.setPackOauthConfig = exports.getPackOauthConfig = exports.updatePackRelease = exports.createPackRelease = exports.listPackReleases = exports.packVersionUploadComplete = exports.registerPackVersion = exports.getPackVersionDiffs = exports.getNextPackVersion = exports.listPackVersions = exports.getPackConfigurationSchema = exports.updatePack = exports.getPack = exports.deletePack = exports.createPack = exports.listPacks = exports.listWorkspaceRoleActivity = exports.changeUserRole = exports.listWorkspaceMembers = exports.getAnalyticsLastUpdated = exports.listPackFormulaAnalytics = exports.listPackAnalyticsSummary = void 0;
exports.addGoLink = void 0;
const client_gen_1 = require("./client.gen");
/**
 * Get doc categories
 * Gets all available doc categories.
 */
const listCategories = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/categories",
        ...options,
    });
};
exports.listCategories = listCategories;
/**
 * List available docs
 * Returns a list of Coda docs accessible by the user, and which they have opened at least once. These are returned in the same order as on the docs page: reverse chronological by the latest event relevant to the user (last viewed, edited, or shared).
 *
 */
const listDocs = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs",
        ...options,
    });
};
exports.listDocs = listDocs;
/**
 * Create doc
 * Creates a new Coda doc, optionally copying an existing doc. Note that creating a doc requires you to be a Doc Maker in the applicable workspace (or be auto-promoted to one).
 *
 */
const createDoc = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.createDoc = createDoc;
/**
 * Delete doc
 * Deletes a doc.
 */
const deleteDoc = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}",
        ...options,
    });
};
exports.deleteDoc = deleteDoc;
/**
 * Get info about a doc
 * Returns metadata for the specified doc.
 */
const getDoc = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}",
        ...options,
    });
};
exports.getDoc = getDoc;
/**
 * Update doc
 * Updates metadata for a doc. Note that updating a doc title requires you to be a Doc Maker in the applicable workspace.
 */
const updateDoc = (options) => {
    return (options.client ?? client_gen_1.client).patch({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updateDoc = updateDoc;
/**
 * Get sharing metadata
 * Returns metadata associated with sharing for this Coda doc.
 */
const getSharingMetadata = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/metadata",
        ...options,
    });
};
exports.getSharingMetadata = getSharingMetadata;
/**
 * List permissions
 * Returns a list of permissions for this Coda doc.
 */
const getPermissions = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/permissions",
        ...options,
    });
};
exports.getPermissions = getPermissions;
/**
 * Add permission
 * Adds a new permission to the doc.
 *
 */
const addPermission = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/permissions",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addPermission = addPermission;
/**
 * Delete permission
 * Deletes an existing permission.
 *
 */
const deletePermission = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/permissions/{permissionId}",
        ...options,
    });
};
exports.deletePermission = deletePermission;
/**
 * Search principals
 * Searches for user and group principals matching the query that this doc can be shared with.
 * At most 20 results will be returned for both users and groups. If no query is given then no results are returned.
 *
 */
const searchPrincipals = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/principals/search",
        ...options,
    });
};
exports.searchPrincipals = searchPrincipals;
/**
 * Get ACL settings
 * Returns settings associated with ACLs for this Coda doc.
 */
const getAclSettings = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/settings",
        ...options,
    });
};
exports.getAclSettings = getAclSettings;
/**
 * Update ACL settings
 * Update settings associated with ACLs for this Coda doc.
 */
const updateAclSettings = (options) => {
    return (options.client ?? client_gen_1.client).patch({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/acl/settings",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updateAclSettings = updateAclSettings;
/**
 * Unpublish doc
 * Unpublishes a doc.
 */
const unpublishDoc = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/publish",
        ...options,
    });
};
exports.unpublishDoc = unpublishDoc;
/**
 * Publish doc
 * Update publish settings for a doc.
 */
const publishDoc = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/publish",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.publishDoc = publishDoc;
/**
 * List pages
 * Returns a list of pages in a Coda doc.
 */
const listPages = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages",
        ...options,
    });
};
exports.listPages = listPages;
/**
 * Create a page
 * Create a new page in a doc. Note that creating a page requires you to be a Doc Maker in the applicable workspace.
 *
 */
const createPage = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.createPage = createPage;
/**
 * Delete a page
 * Deletes the specified page.
 */
const deletePage = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages/{pageIdOrName}",
        ...options,
    });
};
exports.deletePage = deletePage;
/**
 * Get a page
 * Returns details about a page.
 */
const getPage = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages/{pageIdOrName}",
        ...options,
    });
};
exports.getPage = getPage;
/**
 * Update a page
 * Update properties for a page. Note that updating a page title or icon requires you to be a Doc Maker in the applicable workspace.
 *
 */
const updatePage = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages/{pageIdOrName}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updatePage = updatePage;
/**
 * Begin content export
 * Initiate an export of content for the given page.
 */
const beginPageContentExport = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages/{pageIdOrName}/export",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.beginPageContentExport = beginPageContentExport;
/**
 * Content export status
 * Check the status of a page content export
 */
const getPageContentExportStatus = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/pages/{pageIdOrName}/export/{requestId}",
        ...options,
    });
};
exports.getPageContentExportStatus = getPageContentExportStatus;
/**
 * List tables
 * Returns a list of tables in a Coda doc.
 */
const listTables = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/docs/{docId}/tables",
        ...options,
    });
};
exports.listTables = listTables;
/**
 * Get a table
 * Returns details about a specific table or view.
 */
const getTable = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}",
        ...options,
    });
};
exports.getTable = getTable;
/**
 * List columns
 * Returns a list of columns in a table.
 */
const listColumns = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/columns",
        ...options,
    });
};
exports.listColumns = listColumns;
/**
 * Delete multiple rows
 * Deletes the specified rows from the table or view. This endpoint will always return a 202. Row deletions are generally processed within several seconds.
 *
 */
const deleteRows = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.deleteRows = deleteRows;
/**
 * List table rows
 * Returns a list of rows in a table.
 * ### Value results
 * The `valueFormat` parameter dictates in what format the API should return values for individual cells.
 * * `simple` (default): Returns cell values as the following JSON values: `string`, `number`, or `boolean`. Array values (like multiselects) are returned as comma-delimited strings.
 * * `simpleWithArrays`: Singleton values are returned as `simple`. Array values are returned as JSON arrays and the values within are `simple` values (including nested arrays).
 * * `rich`: If applicable, returns many values with further encoding, allowing API users to have lossless access to data in Coda.
 * * For `text` values, returns data in Markdown syntax. If the text field is simple text (e.g. has no formatting),
 * the field will be fully escaped with triple-ticks. E.g
 * `
 * ```This is plain text```
 * `
 * * For `currency`, `lookup`, `image`, `person` and `hyperlink` values, the value will be encoded in [JSON-LD](https://json-ld.org/) format.
 *
 * ```
 * // Currency
 * {
 * "@context": "http://schema.org",
 * "@type": "MonetaryAmount",
 * "currency": "USD",
 * "amount": 42.42
 * }
 *
 * // Lookup
 * {
 * "@context": "http://schema.org",
 * "@type": "StructuredValue",
 * "additionalType": "row",
 * "name": "Row Name",
 * "rowId": "i-123456789",
 * "tableId": "grid-123456789",
 * "tableUrl": "https://coda.io/d/_d123456789/grid-123456789",
 * "url": "https://coda.io/d/_d123456789/grid-123456789#_r42",
 * }
 *
 * // Hyperlink
 * {
 * "@context": "http://schema.org",
 * "@type": "WebPage",
 * "name": "Coda",
 * "url": "https://coda.io"
 * }
 *
 * // Image
 * {
 * "@context": "http://schema.org",
 * "@type": "ImageObject",
 * "name": "Coda logo",
 * "url": "https://coda.io/logo.jpg"
 * }
 *
 * // People
 * {
 * "@context": "http://schema.org",
 * "@type": "Person",
 * "name": "Art Vandalay",
 * "email": "art@vandalayindustries.com"
 * }
 * ```
 *
 */
const listRows = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows",
        ...options,
    });
};
exports.listRows = listRows;
/**
 * Insert/upsert rows
 * Inserts rows into a table, optionally updating existing rows if any upsert key columns are provided. This endpoint will always return a 202, so long as the doc and table exist and are accessible (and the update is structurally valid). Row inserts/upserts are generally processed within several seconds. Note: this endpoint only works for base tables, not views.
 * When upserting, if multiple rows match the specified key column(s), they will all be updated with the specified value.
 *
 */
const upsertRows = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.upsertRows = upsertRows;
/**
 * Delete row
 * Deletes the specified row from the table or view. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row deletions are generally processed within several seconds. When deleting using a name as opposed to an ID, an arbitrary row will be removed.
 *
 */
const deleteRow = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}",
        ...options,
    });
};
exports.deleteRow = deleteRow;
/**
 * Get a row
 * Returns details about a row in a table.
 */
const getRow = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}",
        ...options,
    });
};
exports.getRow = getRow;
/**
 * Update row
 * Updates the specified row in the table. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row updates are generally processed within several seconds. When updating using a name as opposed to an ID, an arbitrary row will be affected.
 *
 */
const updateRow = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updateRow = updateRow;
/**
 * Push a button
 * Pushes a button on a row in a table.
 * Authorization note: This action is available to API tokens that are authorized to write to the table. However, the underlying button can perform any action on the document, including writing to other tables and performing Pack actions.
 *
 */
const pushButton = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}/buttons/{columnIdOrName}",
        ...options,
    });
};
exports.pushButton = pushButton;
/**
 * Get a column
 * Returns details about a column in a table.
 */
const getColumn = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/tables/{tableIdOrName}/columns/{columnIdOrName}",
        ...options,
    });
};
exports.getColumn = getColumn;
/**
 * List formulas
 * Returns a list of named formulas in a Coda doc.
 */
const listFormulas = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/formulas",
        ...options,
    });
};
exports.listFormulas = listFormulas;
/**
 * Get a formula
 * Returns info on a formula.
 */
const getFormula = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/formulas/{formulaIdOrName}",
        ...options,
    });
};
exports.getFormula = getFormula;
/**
 * List controls
 * Returns a list of controls in a Coda doc.
 */
const listControls = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/controls",
        ...options,
    });
};
exports.listControls = listControls;
/**
 * Get a control
 * Returns info on a control.
 */
const getControl = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/controls/{controlIdOrName}",
        ...options,
    });
};
exports.getControl = getControl;
/**
 * List custom doc domains
 * List all custom domains for a published doc.
 */
const listCustomDocDomains = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/${docId}/domains",
        ...options,
    });
};
exports.listCustomDocDomains = listCustomDocDomains;
/**
 * Add custom domain
 * Add a custom domain to a published doc.
 */
const addCustomDocDomain = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/${docId}/domains",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addCustomDocDomain = addCustomDocDomain;
/**
 * Deletes a custom domain
 * Deletes a custom domain from a published doc.
 */
const deleteCustomDocDomain = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/domains/{customDocDomain}",
        ...options,
    });
};
exports.deleteCustomDocDomain = deleteCustomDocDomain;
/**
 * Updates a custom domain
 * Updates properties of a document's custom domain.
 */
const updateCustomDocDomain = (options) => {
    return (options.client ?? client_gen_1.client).patch({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/domains/{customDocDomain}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updateCustomDocDomain = updateCustomDocDomain;
/**
 * Gets custom doc domains providers
 * Gets the provider (ie. GoDaddy) of a custom domain.
 */
const getCustomDocDomainProvider = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/domains/provider/{customDocDomain}",
        ...options,
    });
};
exports.getCustomDocDomainProvider = getCustomDocDomainProvider;
/**
 * Get user info
 * Returns basic info about the current user.
 */
const whoami = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/whoami",
        ...options,
    });
};
exports.whoami = whoami;
/**
 * Resolve browser link
 * Given a browser link to a Coda object, attempts to find it and return metadata that can be used to get more info on it. Returns a 400 if the URL does not appear to be a Coda URL or a 404 if the resource cannot be located with the current credentials.
 *
 */
const resolveBrowserLink = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/resolveBrowserLink",
        ...options,
    });
};
exports.resolveBrowserLink = resolveBrowserLink;
/**
 * Get mutation status
 * Get the status for an asynchronous mutation to know whether or not it has been completed. Each API endpoint that mutates a document will return a request id that you can pass to this endpoint to check the completion status. Status information is not guaranteed to be available for more than one day after the mutation was completed. It is intended to be used shortly after the request was made.
 *
 */
const getMutationStatus = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/mutationStatus/{requestId}",
        ...options,
    });
};
exports.getMutationStatus = getMutationStatus;
/**
 * Trigger automation
 * Triggers webhook-invoked automation
 */
const triggerWebhookAutomation = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/docs/{docId}/hooks/automation/{ruleId}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.triggerWebhookAutomation = triggerWebhookAutomation;
/**
 * List doc analytics
 * Returns analytics data for available docs per day.
 *
 */
const listDocAnalytics = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/analytics/docs",
        ...options,
    });
};
exports.listDocAnalytics = listDocAnalytics;
/**
 * List page analytics
 * Returns analytics data for a given doc within the day.
 * This method will return a 401 if the given doc is not in an Enterprise workspace.
 *
 */
const listPageAnalytics = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/analytics/docs/{docId}/pages",
        ...options,
    });
};
exports.listPageAnalytics = listPageAnalytics;
/**
 * Get doc analytics summary
 * Returns summarized analytics data for available docs.
 *
 */
const listDocAnalyticsSummary = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/analytics/docs/summary",
        ...options,
    });
};
exports.listDocAnalyticsSummary = listDocAnalyticsSummary;
/**
 * List Pack analytics
 * Returns analytics data for Packs the user can edit.
 *
 */
const listPackAnalytics = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/analytics/packs",
        ...options,
    });
};
exports.listPackAnalytics = listPackAnalytics;
/**
 * Get Pack analytics summary
 * Returns summarized analytics data for Packs the user can edit.
 *
 */
const listPackAnalyticsSummary = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/analytics/packs/summary",
        ...options,
    });
};
exports.listPackAnalyticsSummary = listPackAnalyticsSummary;
/**
 * List Pack formula analytics
 * Returns analytics data for Pack formulas.
 *
 */
const listPackFormulaAnalytics = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/analytics/packs/{packId}/formulas",
        ...options,
    });
};
exports.listPackFormulaAnalytics = listPackFormulaAnalytics;
/**
 * Get analytics last updated day
 * Returns days based on Pacific Standard Time when analytics were last updated.
 *
 */
const getAnalyticsLastUpdated = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/analytics/updated",
        ...options,
    });
};
exports.getAnalyticsLastUpdated = getAnalyticsLastUpdated;
/**
 * List workspace users
 * Returns a list of members in the given workspace. This list will be ordered with the requesting user first and then ordered by role.
 *
 */
const listWorkspaceMembers = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/workspaces/{workspaceId}/users",
        ...options,
    });
};
exports.listWorkspaceMembers = listWorkspaceMembers;
/**
 * Updates user role
 * Updates the workspace user role of a user that matches the parameters. Only succeeds if the requesting user has admin permissions in the workspace.
 *
 */
const changeUserRole = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/workspaces/{workspaceId}/users/role",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.changeUserRole = changeUserRole;
/**
 * List workspace roles
 * Returns a list of the counts of users over time by role for the workspace.
 *
 */
const listWorkspaceRoleActivity = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/workspaces/{workspaceId}/roles",
        ...options,
    });
};
exports.listWorkspaceRoleActivity = listWorkspaceRoleActivity;
/**
 * List Packs
 * Get the list of accessible Packs.
 *
 */
const listPacks = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/packs",
        ...options,
    });
};
exports.listPacks = listPacks;
/**
 * Create Pack
 * Creates a new Pack, essentially registering a new Pack ID. The contents of the Pack will be uploaded separately.
 *
 */
const createPack = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.createPack = createPack;
/**
 * Delete Pack
 * Delete a given Pack.
 *
 */
const deletePack = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}",
        ...options,
    });
};
exports.deletePack = deletePack;
/**
 * Get a single Pack
 * Returns a single Pack.
 *
 */
const getPack = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}",
        ...options,
    });
};
exports.getPack = getPack;
/**
 * Update Pack
 * Update an existing Pack for non-versioned fields.
 *
 */
const updatePack = (options) => {
    return (options.client ?? client_gen_1.client).patch({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updatePack = updatePack;
/**
 * Gets the JSON Schema for Pack configuration.
 * Returns a JSON Schema applicable for customizing the pack using Pack configurations.
 *
 */
const getPackConfigurationSchema = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/configurations/schema",
        ...options,
    });
};
exports.getPackConfigurationSchema = getPackConfigurationSchema;
/**
 * List the versions for a Pack.
 * Get the list of versions of a Pack.
 *
 */
const listPackVersions = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions",
        ...options,
    });
};
exports.listPackVersions = listPackVersions;
/**
 * Get the next valid version for a Pack.
 * Get the next valid version based on the proposed metadata.
 *
 */
const getNextPackVersion = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/nextVersion",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.getNextPackVersion = getNextPackVersion;
/**
 * Get the difference between two pack versions.
 * Gets information about the difference between the specified previous version and next version of a Pack.
 *
 */
const getPackVersionDiffs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions/{basePackVersion}/diff/{targetPackVersion}",
        ...options,
    });
};
exports.getPackVersionDiffs = getPackVersionDiffs;
/**
 * Register Pack version
 * Registers a new Pack version. This simply returns a signed URL to use for uploading the Pack version definition. Following the completion of the upload, POST to /apis/v1/packs/{packId}/versions/{packVersion} trigger the rest of the creation process.
 *
 */
const registerPackVersion = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions/{packVersion}/register",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.registerPackVersion = registerPackVersion;
/**
 * Pack version upload complete
 * Note the completion of the upload of a Pack version bundle in order to create that Pack version.
 *
 */
const packVersionUploadComplete = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions/{packVersion}/uploadComplete",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.packVersionUploadComplete = packVersionUploadComplete;
/**
 * List the releases for a Pack.
 * Get the list of releases of a Pack.
 *
 */
const listPackReleases = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/releases",
        ...options,
    });
};
exports.listPackReleases = listPackReleases;
/**
 * Create a new Pack release.
 * Creates a new Pack release based on an existing Pack version.
 *
 */
const createPackRelease = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/releases",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.createPackRelease = createPackRelease;
/**
 * Update an existing Pack release.
 * Update details of a Pack release.
 *
 */
const updatePackRelease = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/releases/{packReleaseId}",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updatePackRelease = updatePackRelease;
/**
 * Retrieve the OAuth configuration of the Pack.
 * Retrieve the OAuth configuration of the Pack for display purpose. Secrets will be returned with masks.
 *
 */
const getPackOauthConfig = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/oauthConfig",
        ...options,
    });
};
exports.getPackOauthConfig = getPackOauthConfig;
/**
 * Set the OAuth configurations of the Pack.
 * Set the OAuth configurations of the Pack, including client id and secret.
 *
 */
const setPackOauthConfig = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/oauthConfig",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.setPackOauthConfig = setPackOauthConfig;
/**
 * Retrieve the system connection metadata of the Pack.
 * Retrieve the system connection metadata of the Pack.
 *
 */
const getPackSystemConnection = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/systemConnection",
        ...options,
    });
};
exports.getPackSystemConnection = getPackSystemConnection;
/**
 * Patch the system connection credentials of the Pack.
 * Patch the system connection credentials of the Pack.
 *
 */
const patchPackSystemConnection = (options) => {
    return (options.client ?? client_gen_1.client).patch({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/systemConnection",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.patchPackSystemConnection = patchPackSystemConnection;
/**
 * Set the system connection credentials of the Pack.
 * Set the system connection credentials of the Pack.
 *
 */
const setPackSystemConnection = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/systemConnection",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.setPackSystemConnection = setPackSystemConnection;
/**
 * List permissions for a Pack
 * Get user, workspace, and/or global permissions for a given Pack.
 *
 */
const getPackPermissions = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/permissions",
        ...options,
    });
};
exports.getPackPermissions = getPackPermissions;
/**
 * Add a permission for Pack
 * Create or modify user, workspace, or global permissions for a given Pack.
 *
 */
const addPackPermission = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/permissions",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addPackPermission = addPackPermission;
/**
 * Delete a permission for Pack
 * Delete user, workspace, or global permissions for a given Pack.
 *
 */
const deletePackPermission = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/permissions/{permissionId}",
        ...options,
    });
};
exports.deletePackPermission = deletePackPermission;
/**
 * List makers for Pack
 * List makers for a given pack.
 *
 */
const listPackMakers = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/makers",
        ...options,
    });
};
exports.listPackMakers = listPackMakers;
/**
 * Add a maker for Pack
 * Set a maker for a given Pack. Used to display makers for a pack in the corresponding packs page.
 *
 */
const addPackMaker = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/maker",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addPackMaker = addPackMaker;
/**
 * Delete a maker for Pack
 * Delete a maker for a given Pack, who will not be displayed in the corresponding packs page.
 *
 */
const deletePackMaker = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/maker/{loginId}",
        ...options,
    });
};
exports.deletePackMaker = deletePackMaker;
/**
 * List categories for Pack
 * List publishing categories for a given pack.
 *
 */
const listPackCategories = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/categories",
        ...options,
    });
};
exports.listPackCategories = listPackCategories;
/**
 * Add a category for Pack
 * Add a publishing category for a given pack.
 *
 */
const addPackCategory = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/category",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addPackCategory = addPackCategory;
/**
 * Delete a category for Pack
 * Delete a publishing category for a given pack.
 *
 */
const deletePackCategory = (options) => {
    return (options.client ?? client_gen_1.client).delete({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/category/{categoryName}",
        ...options,
    });
};
exports.deletePackCategory = deletePackCategory;
/**
 * Upload a Pack asset.
 * Request a signed s3 URL to upload your Pack asset.
 *
 */
const uploadPackAsset = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/uploadAsset",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.uploadPackAsset = uploadPackAsset;
/**
 * Upload Pack source code.
 * Request a signed s3 URL to upload your Pack source code.
 *
 */
const uploadPackSourceCode = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/uploadSourceCode",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.uploadPackSourceCode = uploadPackSourceCode;
/**
 * Pack asset upload complete
 * Note the completion of the upload of a Pack asset.
 *
 */
const packAssetUploadComplete = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/assets/{packAssetId}/assetType/{packAssetType}/uploadComplete",
        ...options,
    });
};
exports.packAssetUploadComplete = packAssetUploadComplete;
/**
 * Pack source code upload complete
 * Note the completion of the upload of a Pack source code.
 *
 */
const packSourceCodeUploadComplete = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions/{packVersion}/sourceCode/uploadComplete",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.packSourceCodeUploadComplete = packSourceCodeUploadComplete;
/**
 * get the source code for a Pack version.
 * Get temporary links used to download the source code for the given packId and version
 *
 */
const getPackSourceCode = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/versions/{packVersion}/sourceCode",
        ...options,
    });
};
exports.getPackSourceCode = getPackSourceCode;
/**
 * List the Pack listings accessible to a user.
 * Get listings of public Packs and Packs created by you.
 *
 */
const listPackListings = (options) => {
    return (options?.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/packs/listings",
        ...options,
    });
};
exports.listPackListings = listPackListings;
/**
 * Get detailed listing information for a Pack.
 * Get detailed listing information for a Pack.
 *
 */
const getPackListing = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/listing",
        ...options,
    });
};
exports.getPackListing = getPackListing;
/**
 * Retrieve the logs of a Pack.
 * Retrieve the logs of a Pack for debugging purpose.
 *
 */
const listPackLogs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/packs/{packId}/docs/{docId}/logs",
        ...options,
    });
};
exports.listPackLogs = listPackLogs;
/**
 * Retrieve the logs of a Ingestion.
 * Retrieve the logs of a Ingestion for debugging purpose.
 */
const listIngestionLogs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        querySerializer: {
            array: {
                explode: false,
                style: "form",
            },
        },
        url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/logs",
        ...options,
    });
};
exports.listIngestionLogs = listIngestionLogs;
/**
 * Retrieve the grouped logs of a Pack.
 * Retrieve the grouped logs of a Pack for debugging purpose.
 *
 */
const listGroupedPackLogs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/docs/{docId}/groupedLogs",
        ...options,
    });
};
exports.listGroupedPackLogs = listGroupedPackLogs;
/**
 * Retrieve the grouped logs of a Pack for a specific ingestionExecutionId.
 * Retrieve the grouped logs of a Pack for debugging purpose.
 *
 */
const listGroupedIngestionLogs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/groupedLogs",
        ...options,
    });
};
exports.listGroupedIngestionLogs = listGroupedIngestionLogs;
/**
 * Retrieve a list of ingestion execution ids for the given root ingestion id.
 * Retrieve the ingestion execution ids of a root ingestion for debugging purpose.
 *
 */
const listIngestionExecutions = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutions",
        ...options,
    });
};
exports.listIngestionExecutions = listIngestionExecutions;
/**
 * Retrieve a list of ingestion execution ids for the given root ingestion id.
 * Retrieve the ingestion execution ids of a root ingestion for debugging purpose.
 *
 */
const listIngestionExecutionAttempts = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutionId/{ingestionExecutionId}/attempts",
        ...options,
    });
};
exports.listIngestionExecutionAttempts = listIngestionExecutionAttempts;
/**
 * Retrieve the information for a specific log.
 * Retrieve the ingestion execution ids of a root ingestion for debugging purpose.
 *
 */
const getPackLogDetails = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/logs/{logId}",
        ...options,
    });
};
exports.getPackLogDetails = getPackLogDetails;
/**
 * List featured docs for a Pack
 * Returns a list of featured doc ids for a Pack.
 *
 */
const listPackFeaturedDocs = (options) => {
    return (options.client ?? client_gen_1.client).get({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/featuredDocs",
        ...options,
    });
};
exports.listPackFeaturedDocs = listPackFeaturedDocs;
/**
 * Update featured docs for a Pack
 * Create or replace the featured docs for a Pack.
 *
 */
const updatePackFeaturedDocs = (options) => {
    return (options.client ?? client_gen_1.client).put({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/packs/{packId}/featuredDocs",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.updatePackFeaturedDocs = updatePackFeaturedDocs;
/**
 * Add a go link
 * Adds a new go link for the organization.
 */
const addGoLink = (options) => {
    return (options.client ?? client_gen_1.client).post({
        security: [
            {
                scheme: "bearer",
                type: "http",
            },
        ],
        url: "/organizations/{organizationId}/goLinks",
        ...options,
        headers: {
            "Content-Type": "application/json",
            ...options?.headers,
        },
    });
};
exports.addGoLink = addGoLink;
